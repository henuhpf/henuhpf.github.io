<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-复习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/26/复习/" class="article-date">
  <time datetime="2019-05-26T15:47:59.000Z" itemprop="datePublished">2019-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/26/复习/">Test</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- TOC -->
<ul>
<li><a href="#计算机网络">计算机网络</a></li>
<li><a href="#传输层">传输层</a></li>
<li><a href="#四次挥手">四次挥手</a></li>
<li><a href="#tcp--udp-区别">TCP &amp; UDP 区别</a></li>
<li><a href="#http">HTTP</a></li>
<li><a href="#http特点">HTTP特点</a></li>
<li><a href="#http-状态码">HTTP 状态码</a></li>
<li><a href="#https">HTTPS</a></li>
<li><a href="#http和https区别">HTTP和HTTPS区别</a></li>
<li><a href="#数据库">数据库</a></li>
<li><a href="#为什么要使用索引">为什么要使用索引</a></li>
<li><a href="#什么样的信息能成为索引">什么样的信息能成为索引</a></li>
<li><a href="#索引的数据结构">索引的数据结构</a></li>
<li><a href="#优化sql">优化SQL</a></li>
<li><a href="#事务并发访问存在的问题">事务并发访问存在的问题</a></li>
<li><a href="#linux">Linux</a></li>
<li><a href="#linux-的体系结构">Linux 的体系结构</a></li>
<li><a href="#常用命令">常用命令</a></li>
<li><a href="#查找特定文件">查找特定文件</a></li>
<li><a href="#检索文件内容">检索文件内容</a></li>
<li><a href="#对文件内容做统计">对文件内容做统计</a></li>
<li><a href="#对文件内容批量替换">对文件内容批量替换</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#jvm">JVM</a></li>
<li><a href="#为什么--jvm-不直接将源码解析成机器码去执行平台无关性">为什么  JVM 不直接将源码解析成机器码去执行？（平台无关性）</a></li>
<li><a href="#jvm-如何加载-class-文件">JVM 如何加载 .class 文件</a></li>
<li><a href="#java内存模型-runtime-data-area">Java内存模型 (Runtime Data Area)</a></li>
<li><a href="#jvm三大性能调优参数--xms--xmx--xss-的含义">JVM三大性能调优参数 -Xms -Xmx -Xss 的含义</a></li>
<li><a href="#java-内存模型中-堆和栈-的区别">Java 内存模型中 堆和栈 的区别</a></li>
<li><a href="#反射">反射</a></li>
<li><a href="#类从编译到执行的过程">类从编译到执行的过程</a></li>
<li><a href="#classloader-的种类">ClassLoader 的种类</a></li>
<li><a href="#自定义-classloader-的实现">自定义 ClassLoader 的实现</a></li>
<li><a href="#类加载器的双亲委派机制">类加载器的双亲委派机制</a></li>
<li><a href="#为什么使用双亲委派机制去加载类">为什么使用双亲委派机制去加载类</a></li>
<li><a href="#类的加载方式">类的加载方式</a></li>
<li><a href="#gc">GC</a></li>
<li><a href="#判断对象是否为垃圾的算法">判断对象是否为垃圾的算法</a></li>
<li><a href="#垃圾回收算法">垃圾回收算法</a></li>
<li><a href="#object-的-finalize-方法的作用是否与-c-的析构函数作用相同">Object 的 finalize() 方法的作用是否与 C++ 的析构函数作用相同</a></li>
<li><a href="#java-中的强引用-软引用--弱引用--虚引用-有什么用">Java 中的强引用, 软引用 , 弱引用 , 虚引用 有什么用</a></li>
<li><a href="#线程">线程</a></li>
<li><a href="#进程-和-线程">进程 和 线程</a></li>
<li><a href="#进程和线程的区别">进程和线程的区别</a></li>
<li><a href="#java-进程和线程的关系">Java 进程和线程的关系</a></li>
<li><a href="#thread-中的-start-和-run-方法的区别">Thread 中的 start 和 run 方法的区别</a></li>
<li><a href="#thread-和-runnable-是什么关系">Thread 和 Runnable 是什么关系</a></li>
<li><a href="#如何给-run-方法传参">如何给 run() 方法传参</a></li>
<li><a href="#如何处理线程的返回值">如何处理线程的返回值</a></li>
<li><a href="#线程的状态">线程的状态</a></li>
<li><a href="#sleep-和-wait-的区别">sleep 和 wait 的区别</a></li>
<li><a href="#notify-和-notifyall-的区别">notify 和 notifyAll 的区别</a></li>
<li><a href="#yield">yield</a></li>
<li><a href="#如何中断线程">如何中断线程</a></li>
<li><a href="#线程状态以及状态之间的转换">线程状态以及状态之间的转换</a></li>
<li><a href="#synchronized">synchronized</a></li>
<li><a href="#线程安全问题的主要诱因">线程安全问题的主要诱因</a></li>
<li><a href="#互斥锁的特性">互斥锁的特性</a></li>
<li><a href="#synchronized-锁的不是代码锁的都是对象"><strong><em>synchronized 锁的不是代码，锁的都是对象</em></strong></a></li>
<li><a href="#根据获取的锁的分类--获取对象锁-和-获取类锁">根据获取的锁的分类 : 获取对象锁 和 获取类锁</a></li>
<li><a href="#对象锁-和-类锁的总结">对象锁 和 类锁的总结</a></li>
<li><a href="#synchronized-底层实现原理">synchronized 底层实现原理</a></li>
<li><a href="#实现-synchronized-的基础">实现 synchronized 的基础</a></li>
<li><a href="#自旋锁与自适应自旋锁">自旋锁与自适应自旋锁</a></li>
<li><a href="#锁消除">锁消除</a></li>
<li><a href="#锁粗化">锁粗化</a></li>
<li><a href="#synchronized-的四种状态">synchronized 的四种状态</a></li>
<li><a href="#aqs--abstractqueuesynchronizer-队列同步器是-java-用来构建锁或其他同步组件的基本框架是-juc-package-的核心一般使用其的方式是继承">AQS : AbstractQueueSynchronizer ,队列同步器，是 Java 用来构建锁或其他同步组件的基本框架，是 JUC Package 的核心，一般使用其的方式是继承</a></li>
<li><a href="#synchronized-和-reentrantlock-的区别">synchronized 和 ReentrantLock 的区别</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#什么是-java-内存模型中的-happens-before">什么是 Java 内存模型中的 happens-before</a></li>
<li><a href="#jmm-中的主内存和工作内存">JMM 中的主内存和工作内存</a></li>
<li><a href="#jmm-如何解决可见性问题">JMM 如何解决可见性问题</a></li>
<li><a href="#volatile--jvm-提供的轻量级同步机制">volatile : JVM 提供的轻量级同步机制</a></li>
<li><a href="#volatile-变量为何立即可见">volatile 变量为何立即可见?</a></li>
<li><a href="#volatile-如何禁止重排优化">volatile 如何禁止重排优化</a></li>
<li><a href="#volatile-和-synchronized-的区别">volatile 和 synchronized 的区别</a></li>
<li><a href="#悲观锁-和-乐观锁">悲观锁 和 乐观锁</a></li>
<li><a href="#cas-compare-and-swap">CAS (Compare and Swap)</a></li>
<li><a href="#java-线程池">Java 线程池</a></li>
<li><a href="#forkjoin-框架">Fork/Join 框架</a></li>
<li><a href="#为什么要使用线程池">为什么要使用线程池</a></li>
<li><a href="#juc-的三个-executor-接口">J.U.C 的三个 Executor 接口</a></li>
<li><a href="#threadpoolexecutor-的构造函数">ThreadPoolExecutor 的构造函数</a></li>
<li><a href="#新任务提交-execute-执行后的判断">新任务提交 execute 执行后的判断</a></li>
<li><a href="#线程池的状态">线程池的状态</a></li>
<li><a href="#线程池的大小如何选定">线程池的大小如何选定</a></li>
<li><a href="#java异常以及常用工具类体系">Java异常以及常用工具类体系</a></li>
<li><a href="#java-异常">Java 异常</a></li>
<li><a href="#error-和-exception-的区别">Error 和 Exception 的区别</a></li>
<li><a href="#常见-error-以及-exception">常见 Error 以及 Exception</a></li>
<li><a href="#java-的异常处理机制">Java 的异常处理机制</a></li>
<li><a href="#java-异常的处理原则">Java 异常的处理原则</a></li>
<li><a href="#try-catch">try-catch</a></li>
<li><a href="#java集合框架">Java集合框架</a></li>
<li><a href="#hashmap-hashtable-concurrenthashmap">HashMap 、HashTable 、ConcurrentHashMap</a></li>
<li><a href="#spring">spring</a></li>
<li><a href="#ioc----控制反转">IOC – 控制反转</a></li>
<li><a href="#aop-面向切面变成">AOP 面向切面变成</a></li>
</ul>
<!-- /TOC -->
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><img src="/2019/05/26/复习/计算机网络.png" alt="1552824694528"></p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>​    <img src="/2019/05/26/复习/%5CUsers%5C44524%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1552825286289.png" alt="1552825286289"></p>
<p><img src="/2019/05/26/复习/%5CUsers%5C44524%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1552825448415.png" alt="1552825448415"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 第一次</span><br><span class="line">        第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</span><br><span class="line">* 第二次</span><br><span class="line">		第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+<span class="number">1</span>），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</span><br><span class="line">* 第三次</span><br><span class="line">		第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+<span class="number">1</span>），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</span><br><span class="line">		</span><br><span class="line">隐患  第一次syn 超时问题  server 会重试</span><br></pre></td></tr></table></figure>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul>
<li><p>MSL  最长报文段声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送</span><br><span class="line">（<span class="number">2</span>）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加<span class="number">1</span>（报文段<span class="number">5</span>）。和SYN一样，一个FIN将占用一个序号。</span><br><span class="line">（<span class="number">3</span>）服务器B关闭与客户端A的连接，发送一个FIN给客户端A</span><br><span class="line">（<span class="number">4</span>）客户端A发回ACK报文确认，并将确认序号设置为收到序号加<span class="number">1</span></span><br><span class="line">TCP采用四次挥手关闭连接如图所示为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</span><br><span class="line">这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</span><br></pre></td></tr></table></figure>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p><img src="/2019/05/26/复习/%5CUsers%5C44524%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1552826975193.png" alt="1552826975193"></p>
</li>
</ul>
<p><img src="/2019/05/26/复习/%5CUsers%5C44524%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1552826999250.png" alt="1552826999250"></p>
<h4 id="TCP-amp-UDP-区别"><a href="#TCP-amp-UDP-区别" class="headerlink" title="TCP &amp; UDP 区别"></a>TCP &amp; UDP 区别</h4><p><img src="/2019/05/26/复习/%5CUsers%5C44524%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1552827161264.png" alt="1552827161264"></p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h5 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h5><ul>
<li><p>客户端、服务器模式</p>
</li>
<li><p>简单快速</p>
</li>
<li><p>灵活</p>
</li>
<li><p>无连接</p>
</li>
<li><p>无状态</p>
<h4 id="HTTP请求结构"><a href="#HTTP请求结构" class="headerlink" title="HTTP请求结构"></a>HTTP请求结构</h4><p><img src="/2019/05/26/复习/%5CUsers%5C44524%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1552827722407.png" alt="1552827722407"></p>
<h5 id="HTTP相应结构"><a href="#HTTP相应结构" class="headerlink" title="HTTP相应结构"></a>HTTP相应结构</h5><p><img src="/2019/05/26/复习/%5CUsers%5C44524%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1552827866134.png" alt="1552827866134"></p>
</li>
</ul>
<h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><p><img src="/2019/05/26/复习/%5CUsers%5C44524%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1552828063341.png" alt="1552828063341"></p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul>
<li><p>HTTPS= HTTP+SSL（安全套阶层）</p>
</li>
<li><p>传输流程</p>
<p><img src="/2019/05/26/复习/%5CUsers%5C44524%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1552828339569.png" alt="1552828339569"></p>
</li>
</ul>
<h4 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h4><ul>
<li>s 需要证书</li>
<li>https 密文传输</li>
<li>连接端口不同 80 443</li>
<li>HTTPS = HTTP + 加密 + 认证 + 完整性保护</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h5 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h5><ul>
<li>加快速度，不用扫描整张表</li>
</ul>
<h5 id="什么样的信息能成为索引"><a href="#什么样的信息能成为索引" class="headerlink" title="什么样的信息能成为索引"></a>什么样的信息能成为索引</h5><ul>
<li>主键，唯一键等能让数据具备一定区分性的字段<h5 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h5></li>
<li>常用的是B+树 hash，bitmap ，mysql不支持bitmap <h5 id="优化SQL"><a href="#优化SQL" class="headerlink" title="优化SQL"></a>优化SQL</h5></li>
<li>根据慢日志去定位SQL</li>
<li>使用explain 工具分析SQL<pre><code>- type  表示mysql找到数据行的方式
</code></pre><ul>
<li>extra  using filesort  使用外部索引排序 | using temporary 使用临时表</li>
</ul>
</li>
<li>修改SQL，或者尽量走SQL索引<br> select * from table force index（primary）； 强制使用primary 索引</li>
</ul>
<p>myisam 默认是表级锁，不支持行级锁<br>InnoDB 默认是行级锁，支持表级锁</p>
<h4 id="事务并发访问存在的问题"><a href="#事务并发访问存在的问题" class="headerlink" title="事务并发访问存在的问题"></a>事务并发访问存在的问题</h4><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h4 id="Linux-的体系结构"><a href="#Linux-的体系结构" class="headerlink" title="Linux 的体系结构"></a>Linux 的体系结构</h4><hr>
<ul>
<li><img src="/2019/05/26/复习/44.png" alt="44"></li>
<li>体系结构主要分为用户态 ( 用户上层活动 ) 和内核态</li>
<li>内核 : 本质是一段管理计算机硬件设备的程序</li>
<li>系统调用 : 内核的访问接口，是一种能再简化的操作</li>
<li>公用函数库 : 对系统调用的封装，是系统调用的组合拳</li>
<li>Shell : 命令解释器，可编程</li>
</ul>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><hr>
<ul>
<li>cat more less</li>
<li>vi vim</li>
</ul>
<h6 id="查找特定文件"><a href="#查找特定文件" class="headerlink" title="查找特定文件"></a>查找特定文件</h6><hr>
<ul>
<li>find ~ -name “target3.java” : 精确查找文件</li>
<li>find ~ -name “target*“ : 模糊查询</li>
<li>find ~ -iname “target*“ : 不区分文件名大小写查找文件</li>
<li>man find : 更多关于 find 指令的使用说明</li>
</ul>
<h6 id="检索文件内容"><a href="#检索文件内容" class="headerlink" title="检索文件内容"></a>检索文件内容</h6><hr>
<ul>
<li>grep ‘String’ info.log 查找包含制定字符串的行</li>
<li>grep -o ‘engine\[[0-9a-z]*\]’ 筛选符合正则表达式的内容</li>
<li>grep -v ‘grep’ 过滤掉包含相关字符串的内容</li>
</ul>
<h6 id="对文件内容做统计"><a href="#对文件内容做统计" class="headerlink" title="对文件内容做统计"></a>对文件内容做统计</h6><hr>
<ul>
<li><img src="/2019/05/26/复习/45.png" alt="45"></li>
<li>awk ‘{print $1,$4}’ netstat.txt 筛选出第1，4列的数据</li>
<li>awk ‘$1 == “tcp” &amp;&amp; $2 ==1{print$0}’ netstat.txt 依据条件筛选某些列的数据</li>
<li>awk ‘{enginearr[$1]++}END{for(i in enginearr)print i”\t”enginearr[i]}’ 对内容逐行进行统计操作</li>
</ul>
<h6 id="对文件内容批量替换"><a href="#对文件内容批量替换" class="headerlink" title="对文件内容批量替换"></a>对文件内容批量替换</h6><hr>
<ul>
<li>sed -i ‘s/^Str/String/‘ replace.java 将Str 替换成 String(-i 直接在目标文本修改)</li>
<li>sed -i ‘s/.$/\;/‘ replace.java 筛选出’.’结尾的行，并将 ‘.’ 替换成 ‘;’</li>
<li>sed -i ‘s/Jack/me/g’ replace.java 筛选出包含 Jack 的行，并将 Jack 替换成 me （g 指对整行内容替换，没有 g 只替换每一行第一个Jack） </li>
</ul>
<p><img src="/2019/05/26/复习/TCP-进程通信.jpg" alt="TCP-进程通信"></p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul>
<li>对 Java 的理解<ul>
<li>平台无关性</li>
<li>GC</li>
<li>语言特性 泛型 反射 Lamda</li>
<li>面向对象</li>
<li>类库</li>
<li>异常处理</li>
</ul>
</li>
<li>Java 控制台命令<ul>
<li>javac 编译 .java 文件，生成字节码 .class 文件</li>
<li>java 通过 jvm 解析 .class 文件，转换成特定平台的机器指令</li>
<li>javap -c 反汇编 .class (字节码) 文件</li>
<li>JIT 编译器 即时编译器 (JIT compiler , just -in-time compiler) ，是一个将 Java 的字节码(包括需要被解释的指令的程序) 转换成可以直接发送给处理器的指令的程序。</li>
</ul>
</li>
</ul>
<h4 id="为什么-JVM-不直接将源码解析成机器码去执行？（平台无关性）"><a href="#为什么-JVM-不直接将源码解析成机器码去执行？（平台无关性）" class="headerlink" title="为什么  JVM 不直接将源码解析成机器码去执行？（平台无关性）"></a>为什么  JVM 不直接将源码解析成机器码去执行？（平台无关性）</h4><hr>
<ul>
<li>每次执行都要进行语法，句法的检查，且每次都会重新编译，重新分析，整体性能会受影响，引入中间字节码可以保证在被编译成字节码后，多次执行程序不需要进行校验和补全</li>
<li>可以将别的语言解析成的字节码在 JVM 上运行</li>
</ul>
<h4 id="JVM-如何加载-class-文件"><a href="#JVM-如何加载-class-文件" class="headerlink" title="JVM 如何加载 .class 文件"></a>JVM 如何加载 .class 文件</h4><hr>
<p><img src="/2019/05/26/复习/1.png&quot;Java 虚拟机&quot;" alt="1"></p>
<ul>
<li>Class Loader : 依据特定格式 ,加载 .class 文件到内存</li>
<li>Execution Engine : 对命令进行解析</li>
<li>Native Interface : 融合不同开发语言的原生库为 Java 所用 (在执行时,可以调用别的语言写的库函数)</li>
<li>Runtime Data Area : JVM 内存空间结构模型</li>
<li>PC Register : program count register 程序计数寄存器</li>
</ul>
<h4 id="Java内存模型-Runtime-Data-Area"><a href="#Java内存模型-Runtime-Data-Area" class="headerlink" title="Java内存模型 (Runtime Data Area)"></a>Java内存模型 (Runtime Data Area)</h4><p><a href="https://www.cnblogs.com/lewis0077/p/5143268.html" target="_blank" rel="noopener">https://www.cnblogs.com/lewis0077/p/5143268.html</a></p>
<hr>
<ul>
<li><img src="/2019/05/26/复习/4.png" alt="4"></li>
<li>程序计数器(Program Counter Register) <ul>
<li>是逻辑计数器，不是物理计数器</li>
<li>指向当前线程所执行的字节码行号</li>
<li>改变计数器的值来选取下一条需要执行的字节码指令</li>
<li>和线程是一对一的关系 也即是 “线程私有”</li>
<li>对 Java 方法计数，如果是 Native 方法则计数器值为 Undefined</li>
<li>因为只记录行号，不必担心内存泄漏的问题</li>
</ul>
</li>
<li>Java 虚拟机栈 (Stack)</li>
<li><img src="/2019/05/26/复习/5.png" alt="5"></li>
<li><img src="/2019/05/26/复习/8.png" alt="8"></li>
<li>局部变量表 : 包含方法执行过程中的所有变量</li>
<li>操作数栈 : 入栈、出栈、赋值、交换、产生消费变量 </li>
<li><img src="/2019/05/26/复习/7.png" alt="7"></li>
<li>descriptor :(II) 表示两个int变量</li>
<li>stack=2 两个栈</li>
<li>locals=3 局部变量为3</li>
<li>args_size=2 传入数据为2个</li>
<li><img src="/2019/05/26/复习/6.png" alt="6"><ul>
<li>右边的是7个栈帧</li>
<li>局部变量表是为操作数栈提供必要的技术支撑</li>
<li>递归为什么会引发 java.lang.StackOverflowError 异常<ul>
<li>递归过深，栈帧数超出虚拟机栈深度</li>
<li>限制递归的次数，或者使用循环</li>
</ul>
</li>
<li>虚拟机栈过多会引发 java.lang.OutOfMemoryError 异常</li>
</ul>
</li>
<li>本地方法栈</li>
<li>主要作用于标记了 native 的方法</li>
<li>MetaSpace(元空间) 与 永久代( PermGen)<ul>
<li>元空间使用本地内存，永久代使用 jvm 内存</li>
<li>jdk8后，元空间替代了永久代</li>
<li>MetaSpace 没有字符串常量池,jdk7 时字符串常量池已经移动到了堆中</li>
<li>MetaSpace 相比 PermGen 的优势</li>
<li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li>
<li>类和方法的信息大小难确定，给永久代的大小指定带来困难，太小易出现永久代溢出，太大易导致老年代溢出</li>
<li>永久代会为 GC 带来不必要的复杂性，回收效率偏低</li>
</ul>
</li>
<li>Java堆 (Heap)<ul>
<li><img src="/2019/05/26/复习/9.png" alt="9"></li>
<li>对象实例的分配区域</li>
<li>Java 堆可以处于内存上不连续的内存空间中，只要逻辑上连续即可</li>
<li>GC 管理的主要区域</li>
</ul>
</li>
</ul>
<h4 id="JVM三大性能调优参数-Xms-Xmx-Xss-的含义"><a href="#JVM三大性能调优参数-Xms-Xmx-Xss-的含义" class="headerlink" title="JVM三大性能调优参数 -Xms -Xmx -Xss 的含义"></a>JVM三大性能调优参数 -Xms -Xmx -Xss 的含义</h4><ul>
<li>cmd : java -Xms128m -Xmx128m -Xss256k -jar xxx.jar</li>
<li>-Xss : 规定了每个线程虚拟机栈 (堆栈) 的大小,影响进程中并发数的大小</li>
<li>-Xms : 堆的初始值</li>
<li>-Xmx : 堆能达到的最大值 </li>
</ul>
<h4 id="Java-内存模型中-堆和栈-的区别"><a href="#Java-内存模型中-堆和栈-的区别" class="headerlink" title="Java 内存模型中 堆和栈 的区别"></a>Java 内存模型中 堆和栈 的区别</h4><ul>
<li>内存分配策略<ul>
<li>静态存储 : 编译时确定每个数据目标在运行时的存储空间需求，在编译时，可以给他们分配固定内存空间，这种策略不允许代码中由可变数据结构的存在，以及嵌套和递归</li>
<li>栈式存储 : 动态存储分配，数据区需求在编译时未知，运行时模块入口前确定，先进后出分配</li>
<li>堆式存储 : 编译时或运行时模块入口无法确定，动态分配，如可变长度串、对象实例，可按任意顺序分配</li>
</ul>
</li>
<li>堆和栈的联系 : 引用对象、数组时，栈里定义变量保存堆中目标的首地址</li>
<li><img src="/2019/05/26/复习/10.png" alt="10"></li>
<li>区别<ul>
<li>管理方式 : 栈空间可由 JVM 自动释放，堆需要 GC</li>
<li>空间大小 : 栈比堆小</li>
<li>碎片相关 : 栈碎片远小于堆</li>
<li>分配方式 : 栈支持静态和动态分配，堆只支持动态分配</li>
<li>效率 : 栈的效率比堆高</li>
</ul>
</li>
</ul>
<p><img src="/2019/05/26/复习/11.png" alt="11"></p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><hr>
<p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。</p>
<ul>
<li>反射函数 反射例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rjxy.henu.reflect;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(String helloSentence)</span> </span>&#123;</span><br><span class="line">        System.out.println(helloSentence + <span class="string">" "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">throwHello</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span> + tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rjxy.henu.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class rc = Class.forName(<span class="string">"com.rjxy.henu.reflect.Robot"</span>);<span class="comment">//获取Robot类对象</span></span><br><span class="line">        Robot r = (Robot) rc.newInstance(); <span class="comment">//实例化</span></span><br><span class="line">        System.out.println(<span class="string">"Class name is "</span> + rs.getName());</span><br><span class="line">        Method getHello =  rc.getDeclaredMethod(<span class="string">"throwHello"</span>,String.class);<span class="comment">//可以获取所有的方法（不能获取继承和实现接口的方法）</span></span><br><span class="line">        getHello.setAccessible(<span class="keyword">true</span>);<span class="comment">//访问私有成员，值为 true 该方法指示反射的对象在使用时应取消 Java 语言访问检查，值为false指示反射的对象应实施 Java 语言访问检查。</span></span><br><span class="line">        <span class="comment">// setAccessible 是启用和禁用访问安全检查的开关，并不是为true就能访问为false就不能访问。</span></span><br><span class="line">        Object str = getHello.invoke(r,<span class="string">"Bob"</span>);<span class="comment">//返回"Hello Bob"。</span></span><br><span class="line">        System.out.println(<span class="string">"getHello result is "</span> + str);</span><br><span class="line">        Method sayHi = rc.getMethod();<span class="comment">//可以获取继承，和所实现的接口的public方法 以及本类public方法。</span></span><br><span class="line">        sayHi.invoke(r,<span class="string">"Welcome"</span>);<span class="comment">// Welcome null</span></span><br><span class="line">        Field name = rc.getDeclaredField(<span class="string">"name"</span>);<span class="comment">//获取私有成员变量</span></span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(r,<span class="string">"Alice"</span>);</span><br><span class="line">        sayHi.invoke(r,<span class="string">"Welcome"</span>);<span class="comment">//Welcome Alice</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类从编译到执行的过程"><a href="#类从编译到执行的过程" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h4><hr>
<ul>
<li>编译器将 Robot.java 源文件编译为 Robot.class 字节码文件</li>
<li>ClassLoader 将字节码转换成 JVM 中的 Class<robot> 对象</robot></li>
<li>JVM 利用 Class<robot> 对象实例化为 Robot 对象</robot></li>
</ul>
<h4 id="ClassLoader-的种类"><a href="#ClassLoader-的种类" class="headerlink" title="ClassLoader 的种类"></a>ClassLoader 的种类</h4><hr>
<ul>
<li>BootStrapClassLoader : C++ 编写，加载核心库 java.* </li>
<li>ExtClassLoader : Java 编写，加载扩展库 javax.*</li>
<li>AppClassLoader : Java 编写，加载程序所在目录</li>
<li>自定义 ClassLoader : Java 编写，定制化加载</li>
</ul>
<h4 id="自定义-ClassLoader-的实现"><a href="#自定义-ClassLoader-的实现" class="headerlink" title="自定义 ClassLoader 的实现"></a>自定义 ClassLoader 的实现</h4><hr>
<ul>
<li>关键函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b,<span class="keyword">int</span> off,<span class="keyword">int</span> len) <span class="keyword">throws</span> ClassFormatError &#123;</span><br><span class="line">      <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, b, off, len, <span class="keyword">null</span>);<span class="comment">//byte[] 由字节码文件读取出的.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wali</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Wali"</span>);</span><br><span class="line">    &#125;<span class="comment">//使用 javac 命令编译成字节码文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss MyClassLoader extends ClassLoader &#123;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String path,String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于寻找类文件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于加载类文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        name = path + name + <span class="string">".class"</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(name));</span><br><span class="line">            out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((i = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                in.close;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderChecker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader m = <span class="keyword">new</span> MyClassLoader(path:<span class="string">""</span>,classLoaderName:<span class="string">"myClassLoader"</span> );<span class="comment">//传入之前 .class 的路径</span></span><br><span class="line">        Class c = m.loadClass(name:<span class="string">"Wali"</span>);</span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类加载器的双亲委派机制"><a href="#类加载器的双亲委派机制" class="headerlink" title="类加载器的双亲委派机制"></a>类加载器的双亲委派机制</h4><hr>
<p><img src="/2019/05/26/复习/2.png" alt="2"></p>
<h4 id="为什么使用双亲委派机制去加载类"><a href="#为什么使用双亲委派机制去加载类" class="headerlink" title="为什么使用双亲委派机制去加载类"></a>为什么使用双亲委派机制去加载类</h4><hr>
<ul>
<li>避免多份同样字节码的加载</li>
</ul>
<h4 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h4><hr>
<ul>
<li>隐式加载 : new</li>
<li>显示加载 : loadClass , forName 等</li>
<li>loadClass 和 forName 区别<ul>
<li><img src="/2019/05/26/复习/3.png" alt="3"></li>
<li>Class.forName 得到的 class 是已经初始化完成的</li>
<li>ClassLoader.loadClass 得到的 class 是还没有链接的</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rjxy.henu;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Robot"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rjxy.henu;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadDifference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ClassLoader c = Robot.class.getClassLoader();//执行该语句，静态代码块没有执行，也即是 Robot 类没有初始化. Spring 的延迟加载用到了 ClassLoader</span></span><br><span class="line">        <span class="comment">//Class.forName("rjxy.henu.Robot");//执行静态代码块，Robot类被初始化. 声明 数据库连接驱动的时候，Driver 类中具有静态代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><ul>
<li><p>怎么判断一个对象是不是垃圾 : 该对象没有被其他对象引用，对系统而言，该对象就是垃圾，占据的内存就会被释放</p>
<h5 id="内存溢出-amp-内存泄露"><a href="#内存溢出-amp-内存泄露" class="headerlink" title="内存溢出&amp;内存泄露"></a>内存溢出&amp;内存泄露</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java内存泄漏与内存溢出</span><br><span class="line">内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；</span><br><span class="line"></span><br><span class="line">内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</span><br><span class="line"></span><br><span class="line">memory leak会最终会导致out of memory！</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">以发生的方式来分类，内存泄漏可以分为<span class="number">4</span>类： </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 </span><br><span class="line"><span class="number">2</span>. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 </span><br><span class="line"><span class="number">3</span>. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 </span><br><span class="line"><span class="number">4</span>. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 </span><br><span class="line">-- 重现内存泄露</span><br><span class="line"><span class="number">1</span>、静态集合类引起内存泄露： </span><br><span class="line">像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。（解决：vector设为  <span class="keyword">null</span>)</span><br><span class="line"><span class="number">2</span>.当集合里面的对象属性被修改后，再调用remove（）方法时不起作用</span><br><span class="line"><span class="number">3</span>、监听器 </span><br><span class="line">在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、各种连接 </span><br><span class="line">比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在<span class="keyword">try</span>里面去的连接，在<span class="keyword">finally</span>里面释放连接。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、单例模式</span><br><span class="line"></span><br><span class="line">如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="判断对象是否为垃圾的算法"><a href="#判断对象是否为垃圾的算法" class="headerlink" title="判断对象是否为垃圾的算法"></a>判断对象是否为垃圾的算法</h4><hr>
<ul>
<li><p>引用计数算法 </p>
<ul>
<li>判断对象的引用数量</li>
<li>通过判断对象的引用数量来决定对象是否可以被回收</li>
<li>每个对象实例都有一个引用计数器，被引用则 + 1，完成引用则 - 1；</li>
<li>任何引用计数器为 0 的对象实例都可以被视为垃圾</li>
<li><strong><em>优点</em></strong> : 可以高效执行，程序执行收到的影响较小</li>
<li><strong><em>缺点</em></strong> : 无法检测出循环引用 (父类引用子类，子类引用父类) ，导致内存泄漏</li>
</ul>
</li>
<li><p>可达性分析算法（主流Java垃圾收集器使用）</p>
<ul>
<li>判断对象的<strong>引用链</strong>是否可达来决定对象是否可以被回收<br><img src="/2019/05/26/复习/12.png" alt="12"></li>
<li>可以作为 GC Root 的 对象<ul>
<li>虚拟机栈中引用的对象 (栈帧中的本地变量表)</li>
<li>方法区中的常量引用的对象</li>
<li>方法区中的类静态常量属性引用的对象</li>
<li>本地方法栈中 JNI ( Native 方法) 的引用对象</li>
<li>活跃线程的引用对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><hr>
<ul>
<li><p>标记 - 清除算法 ( Mark and Sweep )</p>
<ul>
<li>标记 : 使用可达性算法从根集合进行扫描 ，对存活的对象进行标记</li>
<li>清除 : 对堆内存从头到尾进行线性遍历，回收不可达对象内存 </li>
<li><img src="/2019/05/26/复习/13.png" alt="13"></li>
</ul>
</li>
<li><p>复制算法 ( Copying ) </p>
<ul>
<li>分为对象面和空闲面</li>
<li>对象在对象面创建</li>
<li>存活的对象被从对象面复制到空闲面</li>
<li>将对象面所有对象内存清除</li>
<li><strong>优点</strong><ul>
<li>解决碎片化的问题</li>
<li>顺序分配内存，简单高效</li>
<li>适用于对象存活率低的场景 ( 年轻代 )</li>
</ul>
</li>
<li><img src="/2019/05/26/复习/14.png" alt="14"></li>
</ul>
</li>
<li><p>标记 - 整理算法 ( Compacting )</p>
<ul>
<li>标记 : 从根集合进行扫描，对存活的对象进行标记</li>
<li>清除 : 移动所有存活对象，且按照内存地址依次排列，然后将末端内存地址以后的内存全部回收。</li>
<li><strong>优点</strong><ul>
<li>避免了内存的不连续性</li>
<li>不需要设置两块内存进行互换</li>
<li>适用于存活率高的场景 ( 老年代 )<br><img src="/2019/05/26/复习/15.png" alt="15"></li>
</ul>
</li>
</ul>
</li>
<li><p>分代收集算法 (Generational Collector)</p>
<ul>
<li>是垃圾回收算法的组合拳</li>
<li>按照对象的生命周期的不同划分到堆中不同的区域，以采用不同的垃圾回收算法</li>
<li><p><img src="/2019/05/26/复习/16.png" alt="16"></p>
</li>
<li><p><img src="/2019/05/26/复习/17.png" alt="17"></p>
</li>
<li><p>分代收集算法的 GC 分类</p>
<ul>
<li>Minor GC : 发生在年轻代当中的垃圾收集工作，采用复制算法</li>
<li>Full GC  ：会对堆区进行一个大规模垃圾回收，会涉及到minorGC ，采用标记整理算法</li>
</ul>
</li>
<li><strong>年轻代 : 尽可能快速的收集掉那些生命周期短的对象</strong><pre><code>- Eden 区
</code></pre><ul>
<li>两个 Survivor 区 (from 区 和 to 区 两个区域会相互转换)</li>
<li><img src="/2019/05/26/复习/18.png" alt="18"></li>
</ul>
</li>
<li>对象如何晋升到老年代<ul>
<li>经历一定 Minor 次数依然存活的对象 ( 可以通过 -XX:MaxTenuringThreshold 修改次数)</li>
<li>Survivor 区中存放不下的对象</li>
<li>新生成的大对象 ( 可以通过 -XX:+PertenuerSizeThreshold 调整大对象的大小 )默认15</li>
</ul>
</li>
<li>常用的性能调优参数<ul>
<li>-XX:SurvivorRatio : Eden 和 Survivor 的比值 , 默认 8:1</li>
<li>-XX:NewRatio : 老年代和年轻代内存大小的比例</li>
<li>-XX:MaxTenuringThreshold : 对象从年轻代晋升到老年代经过 GC 次数的最大阈值</li>
</ul>
</li>
<li><strong>老年代 : 存放生命周期较长的对象</strong><ul>
<li>老年代的回收 : Full GC 和 Major GC</li>
<li>Full GC 比 Minor GC 慢10倍以上，但发生频率低</li>
</ul>
</li>
<li><strong>触发 Full GC 的条件</strong><ul>
<li>老年代空间不足</li>
<li>JDK7 以前永久代空间不足</li>
<li>调用 System.gc()</li>
<li>Minor GC 晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>CMS GC 时出现 promotion failed ( 进行 Minor GC 时 Survivor 空间不足，并且此时老年代也放不下 ),concurrent mode failure (执行 CMS GC 的过程中，同时有对象要放入老年代中,老年代空间不足)</li>
<li>使用 RMI 来进行 RPC 或管理的 JDK 应用，每小时执行1次 Full GC</li>
</ul>
</li>
<li><strong>Stop-the-World</strong> <ul>
<li>JVM由于要执行 GC 而停止了应用程序的执行</li>
<li>任何一种 GC 算法中都会发生</li>
<li>多数 GC 优化通过减少Stop-the-world发生的时间来提高程序性能</li>
</ul>
</li>
<li><strong>Safepoint</strong><ul>
<li>分析过程中对象引用关系不会发生变化的点(线程到达安全点才会停顿下来)</li>
<li>产生 Safepoint 的地方 : 方法调用、循环跳转、异常跳转等</li>
<li>安全点数量得适中</li>
</ul>
</li>
</ul>
</li>
<li><strong>垃圾收集器之间的联系</strong><ul>
<li><img src="/2019/05/26/复习/19.png" alt="19"></li>
<li><strong>年轻代常见的垃圾收集器</strong><ul>
<li>Serial 收集器 ( -XX:+UseSerialGC , 复制算法 JDK1.3之前唯一选择)<ul>
<li>单线程收集, 进行垃圾收集时, 必须暂停所有工作线程</li>
<li>简单高效, Client 模式下默认的年轻代收集器</li>
</ul>
</li>
<li>ParNew 收集器 ( -XX:+UseParNewGC , 复制算法)<ul>
<li>多线程收集，其余行为、特点和 Serial 收集器一样</li>
<li>Server 模式下, 虚拟机首选的收集器</li>
<li>单核执行效率不如 Serial , 在多核下执行才有优势</li>
</ul>
</li>
<li>Parallel Scavenge 收集器 ( -XX:+UseParallelGC , 复制算法)<ul>
<li>比起关注用户线程停顿时间， 更关注系统的吞吐量 (<strong><em>吞吐量 = 运行用户代码时间/( 运行用户代码时间 + 垃圾收集时间 )</em></strong>)</li>
<li>在多核下执行才有优势， Server 模式下默认的年轻代收集器</li>
</ul>
</li>
</ul>
</li>
<li><strong>老年代常见的垃圾收集器</strong><ul>
<li>Serial Old 收集器 ( -XX:+UseSerialOldGC, 标记-整理算法 )<ul>
<li>单线程收集, 进行垃圾收集时, 必须暂停所有工作线程</li>
<li>简单高效, Client 模式下默认的老年代收集器</li>
</ul>
</li>
<li>Parallel Old 收集器 ( -XX:+UseParallelOldGC , 标记-整理算法 )<ul>
<li>多线程， 吞吐量</li>
</ul>
</li>
<li>CMS 收集器 ( -XX:+UseConcMarkSweepGC , 标记-清除算法 )<ul>
<li><strong>初始标记 : stop-the-world</strong></li>
<li>并发标记 : 并发追溯标记，程序不会停顿</li>
<li>并发预清理 : 查找执行并发标记阶段从年轻代晋升到老年代的对象</li>
<li><strong>重新标记 : 暂停虚拟机, 扫描 CMS 堆中的剩余对象</strong></li>
<li>并发清理 : 清理垃圾对象 , 程序不会停顿</li>
<li>并发重置 : 重置 CMS 收集器的数据结构</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>G1 收集器 ( -XX:+UseG1GC , 复制 + 标记 - 整理算法 )<ul>
<li>既用于年轻代，也用于老年代的垃圾收集器</li>
<li>未来可以替换掉 CMS 收集器 </li>
<li><strong>Garbage First 收集器的特点</strong><ul>
<li>并发和并行</li>
<li>分代收集</li>
<li>空间整合</li>
<li>可预测的停顿</li>
</ul>
</li>
<li>将整个 Java 堆内存划分为多个大小相等的 Region</li>
<li>年轻代和老年代不再物理隔离<h4 id="Object-的-finalize-方法的作用是否与-C-的析构函数作用相同"><a href="#Object-的-finalize-方法的作用是否与-C-的析构函数作用相同" class="headerlink" title="Object 的 finalize() 方法的作用是否与 C++ 的析构函数作用相同"></a>Object 的 finalize() 方法的作用是否与 C++ 的析构函数作用相同</h4></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>与 C++ 的析构函数不同，析构函数调用确定，而它是不确定的</li>
<li>将未被引用的对象放置于 F-Queue 队列</li>
<li>方法执行随时可能会被终止</li>
<li>给予对象最后一次重生的机会<h4 id="Java-中的强引用-软引用-弱引用-虚引用-有什么用"><a href="#Java-中的强引用-软引用-弱引用-虚引用-有什么用" class="headerlink" title="Java 中的强引用, 软引用 , 弱引用 , 虚引用 有什么用"></a>Java 中的强引用, 软引用 , 弱引用 , 虚引用 有什么用</h4></li>
</ul>
<hr>
<ul>
<li>强引用 ( Strong Reference )<ul>
<li>最普遍的引用 : Object obj = new Object();</li>
<li>抛出 OutOfMemoryError 终止程序也不会回收具有强引用的对象</li>
<li>通过将对象设置为 null 来弱化引用，使其被回收</li>
</ul>
</li>
<li><p>软引用 ( Soft Reference )</p>
<ul>
<li>对象处在有用但非必须的状态</li>
<li>只有当内存空间不足时，GC会回收该引用的对象的内存</li>
<li>可以用来实现高速缓存</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=  <span class="keyword">new</span> String(<span class="string">"abc"</span>);<span class="comment">//强引用</span></span><br><span class="line">SoftReference&lt;String&gt; softRef = <span class="keyword">new</span> SoftReference&lt;String&gt;(str); <span class="comment">//软引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>弱引用 (Weak Reference )</p>
<ul>
<li>非必须的对象，比软引用更弱一些</li>
<li>GC时会被收回</li>
<li>被回收概率也不大，因为 GC 线程优先级比较低</li>
<li>适用于引用偶尔被使用且不影响垃圾收集的对象</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">WeakReference&lt;String&gt; abcWeabRef = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>虚引用 ( PhantomReference )</p>
<ul>
<li>不会决定对象的生命周期</li>
<li>任何时候都可能被垃圾收集器回收</li>
<li>跟踪对象被垃圾收集器回收的活动，起哨兵作用</li>
<li>必须和引用队列 ReferenceQueue 联合使用</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> Sstring(<span class="string">"abc"</span>);</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference ref = <span class="keyword">new</span> PhantomReference(str,queue);</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="/2019/05/26/复习/20.png" alt="20"></p>
</li>
<li>引用队列 ( ReferenceQueue )<ul>
<li>无实际存储结构， 存储逻辑依赖于内部节点之间的关系来表达</li>
<li>存储关联的且被 GC 的软引用，弱引用以及虚引用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="进程-和-线程"><a href="#进程-和-线程" class="headerlink" title="进程 和 线程"></a>进程 和 线程</h4><hr>
<ul>
<li><img src="/2019/05/26/复习/22.png" alt="22"></li>
<li>Linux 用户态和内核态 如何转换，为什么转换</li>
<li>什么是系统中断</li>
<li>内核态的多线程是如何通过轻量级的方式去实现</li>
</ul>
<h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><hr>
<ul>
<li><strong>进程是资源分配的最小单位，线程是 CPU 调度的最小单位</strong><ul>
<li><img src="/2019/05/26/复习/23.png" alt="23"></li>
<li>所有与进程相关的资源，都被记录在 PCB (Process Control Block 进程控制块) 中</li>
<li>进程是抢占处理机的调度单位；线程属于某个进程，共享其资源</li>
<li>线程只由堆栈寄存器(可用来存储线程内的局部变量)、程序计数器 和 TCB(Thread Control Block) 组成</li>
<li><img src="/2019/05/26/复习/24.png" alt="24"></li>
<li>线程不能被看做独立应用，而进程可看作独立应用</li>
<li>进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径</li>
<li>线程没有独立的地址空间，多进程的程序比多线程的程序健壮</li>
<li>进程的切换比线程的切换开销大</li>
</ul>
</li>
</ul>
<h4 id="Java-进程和线程的关系"><a href="#Java-进程和线程的关系" class="headerlink" title="Java 进程和线程的关系"></a>Java 进程和线程的关系</h4><hr>
<ul>
<li>Java 对操作系统提供的功能进行封装，包括进程和线程</li>
<li>运行一个程序会产生一个进程，进程包含至少一个线程</li>
<li>每个进程对应一个 JVM 实例，多个线程共享 JVM 里的堆</li>
<li>Java 采用单线程变成模型，程序会自动创建主线程</li>
<li>主线程可以创建子线程，原则上要后于子线程完成执行</li>
<li>一个程序是一个可执行文件，一个进程是一个执行中程序的实例</li>
</ul>
<h4 id="Thread-中的-start-和-run-方法的区别"><a href="#Thread-中的-start-和-run-方法的区别" class="headerlink" title="Thread 中的 start 和 run 方法的区别"></a>Thread 中的 start 和 run 方法的区别</h4><hr>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Fight"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Current Thread is : "</span> + Thread.currentThread.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                attack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">"current main thread is : "</span> + Thread.currentThread.getName());</span><br><span class="line">        <span class="comment">//t.run();//输出 main Fight main</span></span><br><span class="line">        t.start();<span class="comment">//输出 main Fight Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="/2019/05/26/复习/21.png" alt="21"></p>
</li>
<li>start() 方法是 native 方法，而且在 cpp 中是new一个线程</li>
<li>调用 start() 方法会创建一个新的子线程并启动</li>
<li>run() 方法只是 Thread 的一个普通方法的调用</li>
</ul>
<h4 id="Thread-和-Runnable-是什么关系"><a href="#Thread-和-Runnable-是什么关系" class="headerlink" title="Thread 和 Runnable 是什么关系"></a>Thread 和 Runnable 是什么关系</h4><hr>
<ul>
<li>Thread 是一个类，Runnable 是一个接口，Thread实现了 Runnable 接口</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">pulbic <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread start : "</span> + <span class="keyword">this</span>.name + <span class="string">",i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"Thread1"</span>);</span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"Thread2"</span>);</span><br><span class="line">        MyThread mt3 = <span class="keyword">new</span> MyThread(<span class="string">"Thread3"</span>);</span><br><span class="line">        mt1.start();</span><br><span class="line">        mt2.start();</span><br><span class="line">        mt3.start();</span><br><span class="line">        <span class="comment">//三个线程交替执行</span></span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread start : "</span> + <span class="keyword">this</span>.name + <span class="string">",i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable mr1 = <span class="keyword">new</span> MyRunnable(<span class="string">"Runnable1"</span>);</span><br><span class="line">        MyRunnable mr2 = <span class="keyword">new</span> MyRunnable(<span class="string">"Runnable2"</span>);</span><br><span class="line">        MyRunnable mr3 = <span class="keyword">new</span> MyRunnable(<span class="string">"Runnable3"</span>);</span><br><span class="line">        <span class="comment">//Runnable 接口中没有 start() 方法，所有需要借助 Thread</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mr1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mr2);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(mr3);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Thread 是实现了 Runnable 接口的类，使得 run()方法 支持多线程</li>
<li>因类的单一继承原则，多使用 Runnable 接口</li>
</ul>
<h4 id="如何给-run-方法传参"><a href="#如何给-run-方法传参" class="headerlink" title="如何给 run() 方法传参"></a>如何给 run() 方法传参</h4><hr>
<ul>
<li>构造函数传参 (如上面的例子)</li>
<li>成员变量传参 (MyRunnable.setName());</li>
<li>回调函数传参 (客户端调用服务器执行一个方法，服务器端执行完后反过来调用客户端的函数)</li>
</ul>
<h4 id="如何处理线程的返回值"><a href="#如何处理线程的返回值" class="headerlink" title="如何处理线程的返回值"></a>如何处理线程的返回值</h4><hr>
<ul>
<li><p>主线程等待法！</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleWait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.currentThread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        value = <span class="string">"data"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CycleWait cw = <span class="keyword">new</span> CycleWait();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(cw);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        while (cw.value == null)&#123;</span></span><br><span class="line"><span class="comment">          Thread.currentThread.sleep(100);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        t.join();<span class="comment">//阻塞当前线程</span></span><br><span class="line">        System.out.println(<span class="string">"value = "</span> + cw.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点 : 需要自己实现循环等待的逻辑，当需要等待的变量变多，代码就会变得异常臃肿，没法做到精准控制</p>
</li>
</ul>
</li>
<li>使用 Thread 类中的 join() 阻塞当前线程以等待子线程处理完毕，比主线程等待法更简单，缺点是力度不够细</li>
<li><p>通过 Callable 接口实现 : 通过 FutureTask 或者 线程池获取</p>
<ul>
<li>通过FutureTask</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String value = <span class="string">"test"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Ready to work"</span>);</span><br><span class="line">        Thread.currentThread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"task done"</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> FutureTaskDemo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        <span class="keyword">if</span>(!task.isDone())&#123;</span><br><span class="line">            System.out.println(<span class="string">"task has not finished, please wait"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"task return: "</span> + task.get());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        task has not finished,please wait</span></span><br><span class="line"><span class="comment">        Ready to work</span></span><br><span class="line"><span class="comment">        //wait 5s</span></span><br><span class="line"><span class="comment">        task done</span></span><br><span class="line"><span class="comment">        task return: test</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过线程池,可以提交多个实现 Callable 的类实现并发的处理结果，方便我们的管理</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService newCachedThreadPool = Exectors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = newCachedThreadPool.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        <span class="keyword">if</span>(!future.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"task has not finished, please wait"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            newCachedThreadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><hr>
<ul>
<li>六个状态<ul>
<li>新建 (New) : 创建后尚未启动的线程的状态</li>
<li>运行(Runnable) : 包括 Running 和 Ready ,处于此状态的线程可能正在运行，也可能在等待 CPU 分配执行时间</li>
<li>无限期等待 (Waiting) : 不会被分配 CPU 执行时间，需要显示被唤醒<ul>
<li>没有设置 Timeout 参数的 Object.wait()方法</li>
<li>没有设置 Timeout 参数的 Thread.join() 方法</li>
<li>LockSupport.park() 方法</li>
</ul>
</li>
<li>限期等待 (Timed Waiting) : 在一定时间后会由系统自动唤醒<ul>
<li>Thread.sleep() 方法</li>
<li>设置了 Timeout 参数的 Object.wait() 方法</li>
<li>设置了 TImeout 参数的 Thread.join() 方法</li>
<li>LockSupport.parkNanos() 方法</li>
<li>LockSupport.parkUntil() 方法</li>
</ul>
</li>
<li>阻塞 (Blocked) : 等待获取排他锁, 例如调用 sleep() 方法，等待用户输入</li>
<li>结束 (Terminated) : 已终止线程的状态，线程已经结束执行，如果在此状态执行 start() 方法，会出现IllegalThreadStateException </li>
</ul>
</li>
</ul>
<h4 id="sleep-和-wait-的区别"><a href="#sleep-和-wait-的区别" class="headerlink" title="sleep 和 wait 的区别"></a>sleep 和 wait 的区别</h4><hr>
<ul>
<li>基本差别<ul>
<li>sleep 是Thread类的方法, wait 是 Object 类中定义的方法，wait 方法是 native 方法</li>
<li>sleep() 方法可以在任何地方使用</li>
<li>wait() 方法只能在 synchronized 方法或 synchronized 块中使用</li>
</ul>
</li>
<li>最主要的本质区别<ul>
<li>Thread.sleep 只会让出 CPU,不会导致锁行为的改变</li>
<li>Object.wait 不仅让出 CPU,还会释放已经占有的同步资源锁</li>
</ul>
</li>
</ul>
<h4 id="notify-和-notifyAll-的区别"><a href="#notify-和-notifyAll-的区别" class="headerlink" title="notify 和 notifyAll 的区别"></a>notify 和 notifyAll 的区别</h4><hr>
<ul>
<li>两个概念<ul>
<li>锁池 EntryList<ul>
<li>当某线程A已经占用了某个对象(不是类)的锁，其他线程B、C想要调用这个对象的某个 synchronized 方法，由于要进入 synchronized 方法之前必须获得该锁的拥有权，此时B、C 就会被阻塞，进入锁池等待锁的释放</li>
</ul>
</li>
<li>等待池 WaitSet<ul>
<li>假设线程 A 调用了某个对象的 wait() 方法, 线程 A 就会释放该对象的锁，同时线程 A 就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁</li>
</ul>
</li>
<li>notifyAll 会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会，没有获取锁的且已经呆在锁池中的线程，只能等待其他机会去获取锁，不能主动回到等待池中</li>
<li>notify 只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</li>
</ul>
</li>
</ul>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><hr>
<ul>
<li>概念 : 当调用 Thread.yield() 函数时，会给线程调度器一个当前线程愿意让出 CPU 使用的暗示，但是线程调度器可能会忽略这个暗示</li>
<li>yield 不会使当前线程让出已经占用的锁</li>
</ul>
<h4 id="如何中断线程"><a href="#如何中断线程" class="headerlink" title="如何中断线程"></a>如何中断线程</h4><hr>
<ul>
<li>调用 interrupt() 方法, 通知线程应该中断了<ol>
<li>如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个 InterruptedException 异常</li>
<li>如果线程处于正常活动状态, 那么会将该线程的中断标志设置为 true, 被设置中断标志的线程将继续正常运行，不受影响</li>
</ol>
</li>
<li>需要被调用的线程配合中断<ul>
<li>在正常运行任务时，经常检查本县城的中断标志位，如果被设置了中断标志就自行停止线程</li>
<li>如果线程处于正常活动状态, 那么会将该线程的中断标志设置为 true, 被设置中断标志的线程将继续正常运行，不受影响</li>
</ul>
</li>
</ul>
<h4 id="线程状态以及状态之间的转换"><a href="#线程状态以及状态之间的转换" class="headerlink" title="线程状态以及状态之间的转换"></a>线程状态以及状态之间的转换</h4><hr>
<p><img src="/2019/05/26/复习/25.png" alt="25"></p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h4 id="线程安全问题的主要诱因"><a href="#线程安全问题的主要诱因" class="headerlink" title="线程安全问题的主要诱因"></a>线程安全问题的主要诱因</h4><hr>
<ul>
<li>存在共享数据 (也称临界资源)</li>
<li>存在多条线程共同操作这些共享数据</li>
<li><strong><em>解决问题的根本方法</em></strong><ul>
<li>同一时刻有且只有一个线程在操作共享数据，其他线程必须等待该线程处理完数据后再怼共享数据进行操作</li>
</ul>
</li>
</ul>
<h4 id="互斥锁的特性"><a href="#互斥锁的特性" class="headerlink" title="互斥锁的特性"></a>互斥锁的特性</h4><hr>
<ul>
<li>互斥性 : 即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块(复合操作)进行访问，互斥性也称为操作的原子性</li>
<li>可见性 : 必须确保在锁被释放之前，对共享变量所做的修改，对于其后获得该锁的另一个线程是可见的 ( 即在获得锁时应获得最新共享变量的值 )，否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。</li>
</ul>
<h4 id="synchronized-锁的不是代码，锁的都是对象"><a href="#synchronized-锁的不是代码，锁的都是对象" class="headerlink" title="synchronized 锁的不是代码，锁的都是对象"></a><strong><em>synchronized 锁的不是代码，锁的都是对象</em></strong></h4><h4 id="根据获取的锁的分类-获取对象锁-和-获取类锁"><a href="#根据获取的锁的分类-获取对象锁-和-获取类锁" class="headerlink" title="根据获取的锁的分类 : 获取对象锁 和 获取类锁"></a>根据获取的锁的分类 : 获取对象锁 和 获取类锁</h4><hr>
<ul>
<li>获取对象锁的两种用法<ol>
<li>同步代码块 ( synchronized(this) , synchronized(类实例对象) )，锁是小括号 () 中的实例对象</li>
<li>同步非静态方法 ( synchronized method ),锁是当前对象的实例对象</li>
</ol>
</li>
<li>获取类锁的两种方法<ol>
<li>同步代码块 ( synchronized (类.class) ), 锁是小括号 () 中的类对象 (Class 对象)</li>
<li>同步静态方法 ( synchronized static method ), 锁是当前对象的类对象 ( Class 对象 )<h5 id="对象锁-和-类锁的总结"><a href="#对象锁-和-类锁的总结" class="headerlink" title="对象锁 和 类锁的总结"></a>对象锁 和 类锁的总结</h5></li>
</ol>
</li>
</ul>
<ol>
<li>有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块</li>
<li>若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块的线程会被阻塞</li>
<li>若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步方法的线程会被阻塞</li>
<li>若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象同步方法的线程会被阻塞，反之亦然</li>
<li>同一个类的不同对象的对象锁互不干扰</li>
<li>类锁由于也是一种特殊的对像锁，因此表现和上述1，2，3，4一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁将会是同步的</li>
<li>类锁和对象锁互不干扰</li>
</ol>
<h4 id="synchronized-底层实现原理"><a href="#synchronized-底层实现原理" class="headerlink" title="synchronized 底层实现原理"></a>synchronized 底层实现原理</h4><hr>
<h6 id="实现-synchronized-的基础"><a href="#实现-synchronized-的基础" class="headerlink" title="实现 synchronized 的基础"></a>实现 synchronized 的基础</h6><ul>
<li>Java 对象头</li>
<li><img src="/2019/05/26/复习/26.png" alt="26"></li>
<li><img src="/2019/05/26/复习/27.png" alt="27"></li>
<li>Monitor : 每个对象天生自带的一把看不见的锁 <a href="https://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file" target="_blank" rel="noopener">源码</a>,存在于每个对象的对象头中</li>
</ul>
<h6 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h6><hr>
<ul>
<li>自旋锁 <ul>
<li>许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得</li>
<li>通过让线程执行忙循环等待锁的释放，不让出 CPU</li>
<li>缺点 : 若锁被其他线程长时间占用，会带来许多性能上的开销</li>
<li>可以通过 preBlockSpin 来更改自旋时间，如果超过，则将该线程挂起</li>
</ul>
</li>
<li>自适应自旋锁<ul>
<li>自旋的次数不再固定</li>
<li>由前一次在同一个锁上的自选时间及锁的拥有者的状态来决定</li>
</ul>
</li>
</ul>
<h6 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h6><hr>
<p>更彻底的优化</p>
<ul>
<li>JIT 编译时，对运行上下文进行扫描，去除不可能存在竞争的锁</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferWithoutSync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(String str1,String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//StringBuffer 是线程安全的，由于 sb 只会在append 方法中使用，append方法是静态方法，不可能被其他线程引用，因此 sb 属于不可能共享的资源， JVM 会自动消除内部的锁</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(str1).append(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h6><hr>
<ul>
<li>在循化中如果每次都对一个变量加锁，会带来不必要的性能浪费，JVM 会自动把锁粗化到循环外</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoarseSync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyString100Times</span> <span class="params">(String target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            sb.append(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="synchronized-的四种状态"><a href="#synchronized-的四种状态" class="headerlink" title="synchronized 的四种状态"></a>synchronized 的四种状态</h6><hr>
<ul>
<li><p>无锁</p>
</li>
<li><p>偏向锁</p>
<ul>
<li>减少同一线程获取锁的代价</li>
<li>大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得</li>
<li>核心思想 : 如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 的结构也变为偏向锁结构，当该线程再次请求锁时，无须再做任何同步操作，即获取锁的过程只需要检查 Mark Word 的锁标记位为偏向锁以及当前线程 Id 等于 Mark Word 的 ThreadID 即可，这样就省去了大量有关锁申请的操作</li>
<li>不适应于锁竞争比较激烈的多线程场合</li>
</ul>
</li>
<li><p>轻量级锁</p>
<ul>
<li>由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁征用的时候，偏向锁就会升级成轻量级锁</li>
<li>适用场景 : 线程交替执行同步块</li>
<li>若存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁</li>
</ul>
</li>
<li><p>重量级锁</p>
</li>
<li><p>锁膨胀的方向 : 无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<h5 id="可重入琐条件"><a href="#可重入琐条件" class="headerlink" title="可重入琐条件"></a>可重入琐条件</h5><p>​    不在函数内受用静态或者全局数据</p>
<p>​    不返回静态或者全局数据，所有的数据都有函数的调用者提供</p>
<p>​    使用本地数据（工作内存），或者通过制造全局数据的本地拷贝来保护全局数据</p>
<p>​    不调用不可充入的函数</p>
</li>
</ul>
<h4 id="AQS-AbstractQueueSynchronizer-队列同步器，是-Java-用来构建锁或其他同步组件的基本框架，是-JUC-Package-的核心，一般使用其的方式是继承"><a href="#AQS-AbstractQueueSynchronizer-队列同步器，是-Java-用来构建锁或其他同步组件的基本框架，是-JUC-Package-的核心，一般使用其的方式是继承" class="headerlink" title="AQS : AbstractQueueSynchronizer ,队列同步器，是 Java 用来构建锁或其他同步组件的基本框架，是 JUC Package 的核心，一般使用其的方式是继承"></a>AQS : AbstractQueueSynchronizer ,队列同步器，是 Java 用来构建锁或其他同步组件的基本框架，是 JUC Package 的核心，一般使用其的方式是继承</h4><h4 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h4><hr>
<ul>
<li>java.util.concurrent 包即 JUC 包</li>
<li><p>ReentranntLock (再入锁)</p>
<ul>
<li>位于 java.util.concurrent.locks 包</li>
<li>和 CountDownLatch、FutureTask、Semaphore 一样基于 AQS 实现 </li>
<li>能够实现比 synchronized 更细粒度的控制，如控制 fairness</li>
<li>调用 lock() 只后，必须调用 unlock() 释放锁</li>
<li>性能未必比 synchronized 高，并且也是可重入的</li>
</ul>
</li>
<li><p>ReentrantLock 公平性的设置</p>
<ul>
<li>ReentrantLock fairLock = new ReentrantLock(true);</li>
<li>参数为 true 时，倾向于将锁赋予等待时间最久的线程</li>
<li><strong><em>公平锁 : 获取锁的顺序按先后调用 lock 方法的顺序 (慎用)</em></strong></li>
<li><strong><em>非公平锁 : 抢占的顺序不一定，看运气</em></strong></li>
<li><strong><em>synchronized 是非公平锁</em></strong></li>
</ul>
</li>
<li>ReentrantLock 将锁对象化<ul>
<li>判断是否有线程，或者某个特定线程，在排队等待获取锁</li>
<li>带超时的获取锁的尝试</li>
<li>感知有没有成功获取到锁</li>
</ul>
</li>
<li>是否能将 wait/notify/notufyAll 对象化 (能)<br>  -JUC 下的 locks.Condition<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6></li>
</ul>
<hr>
<ul>
<li>synchronized 是关键字，ReentrantLock是类</li>
<li>ReentrantLock 可以对获取锁的等待时间进行设置，避免死锁</li>
<li>ReentrantLock 可以获取各种锁的信息</li>
<li>ReentrantLock 可以灵活的实现多路通知</li>
<li><strong><em>机制 : synchronized 操作 Mark Word , Reentrantlock 调用 Unsafe 类的 park() 方法</em></strong></li>
</ul>
<h4 id="什么是-Java-内存模型中的-happens-before"><a href="#什么是-Java-内存模型中的-happens-before" class="headerlink" title="什么是 Java 内存模型中的 happens-before"></a>什么是 Java 内存模型中的 happens-before</h4><hr>
<ul>
<li><img src="/2019/05/26/复习/31.png" alt="31"></li>
<li><p><strong><em>happens - before 的八大原则</em></strong></p>
<ol>
<li>程序次序规则 : 一个线程内，按照代码顺序，书写在前面的操作先行发送于书写在后面的操作;</li>
<li>锁定规则 : 一个 unLock 操作先行发生于后面对同一个锁的 lock 操作;</li>
<li>volatile 变量规则 : 对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则 : 如果操作 A 先行发生于操作 B , 而操作 B 又先行发生于操作 C ，则可以得出操作 A 先行发生于操作 C;</li>
<li>线程启动规则 : Thread 对象的 start() 方法先行发生于此线程的每一个动作;</li>
<li>线程中断规则 : 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生;</li>
<li>线程终结规则 : 线程中所有的操作都先行发生于线程的终止检测, 我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行;</li>
<li>对象终结规则 : 一个对象的初始化完成先行发生于他的 finalize() 方法的开始;</li>
</ol>
</li>
<li><p>happens - before 的概念 </p>
<ul>
<li>如果两个操作不满足上述任意一个 happens-before 规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序：</li>
<li>如果操作 A happens-before 操作 B ,那么操作 A 在内存上所做的操作对操作B 都是可见的.</li>
</ul>
</li>
<li>Java 内存模型 JMM<ul>
<li>Java 内存模型 (即 Java Memory Model, 简称 JMM) 本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量 ( 包括实例字段，静态字段和构成数组对象的元素 )的访问方式</li>
<li><img src="/2019/05/26/复习/29.png" alt="29"></li>
</ul>
</li>
</ul>
<h4 id="JMM-中的主内存和工作内存"><a href="#JMM-中的主内存和工作内存" class="headerlink" title="JMM 中的主内存和工作内存"></a>JMM 中的主内存和工作内存</h4><hr>
<ul>
<li><p>是判断数据是否存在竞争，线程是否安全的主要依据</p>
</li>
<li><p>JMM 中的主内存</p>
<ul>
<li>存储 Java 实例对象</li>
<li>包括成员变量、类信息、常量、静态变量等</li>
<li>属于数据共享的区域，多线程并发操作时会引发线程安全问题</li>
</ul>
</li>
<li><p>JMM 中的工作内存</p>
<ul>
<li>存储当前方法中的所有本地变量信息，本地变量对其他线程不可见</li>
<li>字节码行号指示器、Native 方法信息</li>
<li>属于线程私有数据区域，不存在线程安全问题</li>
</ul>
</li>
<li><p>JMM 与 Java 内存区域划分是不同的概念层次</p>
<p><img src="/2019/05/26/复习/281726404166686.jpg" alt="img"></p>
<ul>
<li>JMM 描述的是一组规则，通过这组规则，控制程序中各个变量在共享数据区域和私有数据区域的访问方式，围绕原子性，有序性、k可见性展开</li>
<li>相似点 : 存在共享区域 和 私有区域</li>
<li>JVM 中主内存属于共享数据区域，从某个程度上讲，应该包括了堆和方法区，工作内存属于私有数据区域，应该包括，程序计数器，虚拟机栈，本地方法栈</li>
</ul>
</li>
<li><p>主内存与工作内存的数据存储类型以及操作方式归纳</p>
<ul>
<li>方法里的基本数据类型本地变量将直接存储在工作内存的栈结构中</li>
<li>引用类型的本地变量 : 引用存储在工作内存的栈帧中，实例存储在主内存中</li>
<li>成员变量、static 变量、类信息均会被存储在主内存中</li>
<li>主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存</li>
</ul>
</li>
</ul>
<h4 id="JMM-如何解决可见性问题"><a href="#JMM-如何解决可见性问题" class="headerlink" title="JMM 如何解决可见性问题"></a>JMM 如何解决可见性问题</h4><hr>
<ul>
<li><img src="/2019/05/26/复习/30.png" alt="30"></li>
<li>指令重排序需要满足的条件<ul>
<li>在单线程下不能改变程序运行的结果</li>
<li>存在数据依赖关系的不允许重排序</li>
<li><strong><em>即 无法通过 happens-before 原则推导出来的，才能进行指令的重排序</em></strong></li>
</ul>
</li>
<li>A 操作的结果需要对 B 操作可见，则 A 与 B 存在 happens-before 关系<ul>
<li>如果存在 happens-before 关系则 i = 1;//线程A执行   j = i;//线程 B 执行 =&gt; j == 1; 成立</li>
</ul>
</li>
</ul>
<h6 id="volatile-JVM-提供的轻量级同步机制"><a href="#volatile-JVM-提供的轻量级同步机制" class="headerlink" title="volatile : JVM 提供的轻量级同步机制"></a>volatile : JVM 提供的轻量级同步机制</h6><ul>
<li>保证被 volatile 修饰的共享变量对所有线程总是可见的<br>-禁止指令重排序优化<h6 id="volatile-变量为何立即可见"><a href="#volatile-变量为何立即可见" class="headerlink" title="volatile 变量为何立即可见?"></a>volatile 变量为何立即可见?</h6></li>
<li>当写一个 volatile 变量时，JMM 会把该线程对应的工作内存中的共享变量值刷新到主内存中</li>
<li>当读取一个 volatile 变量时，JMM 会把该线程对应的工作内存置为无效</li>
</ul>
<h6 id="volatile-如何禁止重排优化"><a href="#volatile-如何禁止重排优化" class="headerlink" title="volatile 如何禁止重排优化"></a>volatile 如何禁止重排优化</h6><ul>
<li><p>内存屏障 (Memory Barrier)</p>
<ol>
<li>保证特定操作的执行顺序 <ul>
<li>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化</li>
</ul>
</li>
<li>保证某些变量的内存可见性<ul>
<li>强制刷出各种 CPU 的缓存数据，因此任何 CPU 上的线程都能读取到这些数据的最新版本</li>
</ul>
</li>
</ol>
</li>
<li><p><strong><em>单例的双重检测实现</em></strong></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一次检测</span></span><br><span class="line">        <span class="keyword">if</span> ( instance == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//多线程环境下可能会出现问题的地方</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><img src="/2019/05/26/复习/32.png" alt="32"></li>
<li>上述代码可以使用 volatile 修饰 instance 变量，禁止指令重排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="volatile-和-synchronized-的区别"><a href="#volatile-和-synchronized-的区别" class="headerlink" title="volatile 和 synchronized 的区别"></a>volatile 和 synchronized 的区别</h4><hr>
<ol>
<li>volatile 本质是在告诉 JVM 当前变量在寄存器 ( 工作内存 )中的值是不确定的，需要从贮存在读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住知道该线程完成变量操作</li>
<li>volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法和类级别</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量修改的可见性和原子性</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞</li>
<li>volatile 标记的变量不会被编译器优化；sybchronized 标记的变量可以被编译器优化</li>
</ol>
<h4 id="悲观锁-和-乐观锁"><a href="#悲观锁-和-乐观锁" class="headerlink" title="悲观锁 和 乐观锁"></a>悲观锁 和 乐观锁</h4><hr>
<ul>
<li>synchronized 属于悲观锁，始终假定会发生并发冲突，会屏蔽一切可能违反数据完整性的操作</li>
<li>CAS 属于乐观锁，假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性，如果提交失败，则会进行重试 （但是可能会发生ABA问题）</li>
</ul>
<h4 id="CAS-Compare-and-Swap"><a href="#CAS-Compare-and-Swap" class="headerlink" title="CAS (Compare and Swap)"></a>CAS (Compare and Swap)</h4><hr>
<ul>
<li>百度 AtomicInteger</li>
<li><p>CAS 是一种高效实现线程安全性的方法</p>
<ul>
<li>支持原子更新操作，适用于计数器，序列发生器(给变量自增的工具)等场景</li>
<li>属于乐观锁机制，号称 lock-free</li>
<li>CAS 操作失败时由开发者决定是继续尝试，还是执行别的操作</li>
</ul>
</li>
<li><p>CAS 思想</p>
<ul>
<li>包含三个操作数 – 内存位置 (V)、预期原值 (A) 和新值(B)</li>
<li>写的时候从主内存中读取原值 A 到工作内存，进行更新操作完毕后，将更新前的A值和主内存中的A进行比较，如果相同，则将B写入到主内存中</li>
</ul>
</li>
<li>CAS 多数情况下对开发者来说是透明的<ul>
<li>J.U.C 的 atomic 包提供了常用的原子性数据类型以及引用、数组等相关原子类型和更新操作工具，是很多线程安全程序的首选</li>
<li>Unsafe 类虽然提供了 CAS 服务，但因能够操纵任意内存地址读写而有隐患</li>
<li>Java 9  以后，可以使用 Variable Handle API 来替代 Unsafe</li>
</ul>
</li>
<li><strong><em>缺点</em></strong><ul>
<li>若循环时间长，则开销很大</li>
<li>只能保证一个共享变量的原子操作</li>
<li>ABA 问题 (解决方案 : AtomicStampedReference ,它可以通过控制变量值的返本?来保证CAS的正确性)</li>
</ul>
</li>
</ul>
<h4 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h4><hr>
<p>背景 : 在 Web 开发中，服务器需要接受并处理请求，所以会为一个请求分配一个线程进行处理，如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际请求的时间和消耗的资源更多。 </p>
<ul>
<li>利用 Executors 创建不同的线程池满足不同场景的需求<ol>
<li>newFixedThreadPool(int nThreads) 指定工作线程数量的线程池</li>
<li>newCachedThreadPool() 处理大量短时间工作任务的线程池<ul>
<li>试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程;</li>
<li>如果线程空置的时间超过阈值，则会被终止并移出缓存;</li>
<li>系统长时间闲置的时候，不会消耗什么资源</li>
</ul>
</li>
<li>newSingleThreadExecutor() 创建唯一的工作者线程来执行任务，如果线程异常结束，会有另一个线程取代它</li>
<li>newSingleThreadScheduledExector() 与 newScheduledThreadPool(int corePoolSize) 定时或者周期性的工作调度，两者的区别在于单一工作线程还是单个线程</li>
<li>newWorkStealingPool() 内部会构建ForkJoinPool,利用 working-stealing算法，并行的处理任务，不保证处理顺序</li>
</ol>
</li>
</ul>
<h6 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork/Join 框架"></a>Fork/Join 框架</h6><ul>
<li>把大任务分割成若干个小任务并行执行，最终汇总每个小人物结果后得到大任务结果的框架</li>
<li><strong><em>Work-Stealing 算法 : 某个线程从其他队列里窃取任务来执行</em></strong><ul>
<li><img src="/2019/05/26/复习/33.png" alt="33"></li>
<li>通常使用双端队列，被窃取任务的线程永远从队列的头部拿任务执行，窃取任务的线程从队列的尾部拿任务执行</li>
</ul>
</li>
</ul>
<h6 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h6><hr>
<ul>
<li>降低进程创建和销毁带来的资源消耗</li>
<li>提高消除的可管理性</li>
<li><img src="/2019/05/26/复习/34.png" alt="34"></li>
</ul>
<h6 id="J-U-C-的三个-Executor-接口"><a href="#J-U-C-的三个-Executor-接口" class="headerlink" title="J.U.C 的三个 Executor 接口"></a>J.U.C 的三个 Executor 接口</h6><hr>
<ul>
<li>Executor : 运行新任务的简单接口，将任务提交和任务执行细节解耦<ul>
<li><img src="/2019/05/26/复习/35.png" alt="35"></li>
</ul>
</li>
<li>ExcetorService : 具备管理执行器和任务生命周期的方法，提交任务机制更完善</li>
<li>ScheduledExecutorService : 支持 Future 和定期执行任务</li>
</ul>
<h6 id="ThreadPoolExecutor-的构造函数"><a href="#ThreadPoolExecutor-的构造函数" class="headerlink" title="ThreadPoolExecutor 的构造函数"></a>ThreadPoolExecutor 的构造函数</h6><pre><code>- ![36](复习\36.png)
- corePoolSize : 核心线程数量
- maximumPoolSize : 线程不够用时能够创建的最大线程
        * 当线程数&gt;=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务
        * 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常
- workQueue : 任务等待队列，当任务提交时，如果线程池中的线程数量大于或等于 corePoolSize 时，把对象封装成 work 对象，放入到等待队列中
- keepAliveTime : 线程空闲时间
        * 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
        * 如果allowCoreThreadTimeout=true，则会直到线程数量=0
- allowCoreThreadTimeout：允许核心线程超时
- threadFactory : 创建新线程, Executors.defaultThreadFacotry()
- rejectedExecutionHandler：任务拒绝处理器
        * 两种情况会拒绝处理任务：
            - 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务
            - 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务
        * 线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常
        * ThreadPoolExecutor类有几个内部实现类来处理这类情况：
            - AbortPolicy 丢弃任务，抛运行时异常
            - CallerRunsPolicy 执行任务
            - DiscardPolicy 忽视，什么都不会发生
            - DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务
        * 实现RejectedExecutionHandler接口，可自定义处理器
    - 实现 RejectedExecutionHandler 接口的自定义 handler
</code></pre><h6 id="新任务提交-execute-执行后的判断"><a href="#新任务提交-execute-执行后的判断" class="headerlink" title="新任务提交 execute 执行后的判断"></a>新任务提交 execute 执行后的判断</h6><hr>
<ul>
<li>如果运行的线程少于 corePoolSize ，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；</li>
<li>如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize , 则只有当 workQueue 满时才创建新的线程区处理任务；</li>
<li>如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若 workQueue 未满，则将请求放入 workQueue 中，等待有空闲的线程区从 workQueue 中取任务并处理；</li>
<li>如果运行的线程数量大于等于 maximumPoolSize ，这时如果 workQueue 已经满了，则通过 handler 所指定的策略来处理任务；</li>
<li><img src="/2019/05/26/复习/37.png" alt="37"></li>
</ul>
<h6 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h6><hr>
<ul>
<li><img src="/2019/05/26/复习/38.png" alt="38"></li>
<li>RUNNING : 能接受新提交的任务，并且也能处理阻塞队列中的任务</li>
<li>SHUTDOWN : 不再接受新提交的任务，但可以处理阻塞队列中已保存的任务(处于 RUNNING 状态时，调用 SHUTDOWN 会进入此状态)</li>
<li>STOP : 不再接受新提交的任务，也不处理队列中的任务(处于 RUNNING 或者 SHUTDOWN 状态时，调用 SHUTDOWNNOW 方法会进入此状态)</li>
<li>TIDYING : 所有任务都已终止</li>
<li>TERMINATED : terminated() 方法执行完后进入该状态</li>
<li><img src="/2019/05/26/复习/39.png" alt="39"></li>
</ul>
<h6 id="线程池的大小如何选定"><a href="#线程池的大小如何选定" class="headerlink" title="线程池的大小如何选定"></a>线程池的大小如何选定</h6><hr>
<ul>
<li>CPU 密集型 : 线程数 = 按照核数或者核数 + 1的设定</li>
<li>I/O 密集型 : 线程数 = CPU 核数 * (1 + 平均等待时间/平均工作时间)</li>
</ul>
<h2 id="Java异常以及常用工具类体系"><a href="#Java异常以及常用工具类体系" class="headerlink" title="Java异常以及常用工具类体系"></a>Java异常以及常用工具类体系</h2><hr>
<h4 id="Java-异常"><a href="#Java-异常" class="headerlink" title="Java 异常"></a>Java 异常</h4><hr>
<ul>
<li>异常处理机制主要回答了三个问题<ul>
<li>What : 异常类型回答了什么会被抛出</li>
<li>Where : 异常堆栈跟踪回答了在哪抛出</li>
<li>Why : 异常信息回答了为什么被抛出<h6 id="Error-和-Exception-的区别"><a href="#Error-和-Exception-的区别" class="headerlink" title="Error 和 Exception 的区别"></a>Error 和 Exception 的区别</h6></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><img src="/2019/05/26/复习/40.png" alt="40"></li>
<li>从概念角度解析 Java 的异常处理机制<ul>
<li>Error : 程序无法处理的系统错误，编译器不做检查</li>
<li>Exception : 程序可以处理的异常，捕获后可能会被恢复</li>
<li>前者是程序无法处理的错误，后者是可以处理的异常</li>
</ul>
</li>
<li>RuntimeException : 运行时异常，如数组下标越界，访问空指针等，程序应当自行避免</li>
<li>非 RuntimeException : 可预知的，从编译器校验的异常</li>
<li>从责任角度看<ol>
<li>Error 属于 JVM 需要负担的责任</li>
<li>RuntimeException 是程序应该负担的责任</li>
<li>Checked Exception 可检查异常是 Java 编译器应该负担的责任</li>
</ol>
</li>
</ul>
<h6 id="常见-Error-以及-Exception"><a href="#常见-Error-以及-Exception" class="headerlink" title="常见 Error 以及 Exception"></a>常见 Error 以及 Exception</h6><hr>
<ul>
<li><p>RuntimeException</p>
<ol>
<li>NullPointerException - 空指针引用异常</li>
<li>ClassCastException - 类型强制转换异常</li>
<li>IllegalArgumentException - 传递非法参数异常</li>
<li>IndexOutOfBoundsException - 下表越界异常</li>
<li>NumberFormatException - 数字格式异常</li>
</ol>
</li>
<li><p>非 RuntimeException</p>
<ol>
<li>ClassNotFoundException - 找不到指定 class 的异常</li>
<li>IOException - IO 异常</li>
</ol>
</li>
<li><p>Error</p>
<ol>
<li>NoClassDefFoundError - 找不到 class 定义的异常<ul>
<li>类依赖的 class 或 jar 不存在</li>
<li>类文件存在，但是存在不同的域中</li>
<li>大小写问题，javac 编译时是无视大小的，很有可能编译出来的 class 文件就与想要的不一样</li>
</ul>
</li>
<li>StackOverflowError - 深递归导致栈被耗尽而抛出的异常</li>
<li>OutOfMemoryError - 内存溢出异常</li>
</ol>
</li>
</ul>
<h5 id="Java-的异常处理机制"><a href="#Java-的异常处理机制" class="headerlink" title="Java 的异常处理机制"></a>Java 的异常处理机制</h5><hr>
<ul>
<li>抛出异常 : 创建异常对象 , 交由运行时系统处理</li>
<li>捕获异常 : 寻找合适的异常处理器处理异常，否则终止运行</li>
</ul>
<h5 id="Java-异常的处理原则"><a href="#Java-异常的处理原则" class="headerlink" title="Java 异常的处理原则"></a>Java 异常的处理原则</h5><hr>
<ul>
<li>具体明确 : 抛出的异常应能通过异常类名和 message 准确说明异常的类型和产生异常的原因；</li>
<li>提早抛出 : 应尽可能早的发现并抛出异常，便于精确定位问题；</li>
<li>延迟捕获 : 异常的捕获和处理应尽可能延迟，让掌握更多信息的作用域来处理异常。</li>
</ul>
<h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><hr>
<ul>
<li>try{} catch(){} finally{}中均有 return 语句时，程序在运行到 return 语句之前，跳转到 finally 中，执行 finally 块中的语句，如果 finally 中有 return 语句 ，则直接返回。</li>
<li>Java 异常处理消耗性能的地方<ul>
<li>try-catch 块影响 JVM 的优化，调用 try-catch 会使代码运行时间增加</li>
<li>异常对象实例需要保存栈快照等信息，开销较大 </li>
</ul>
</li>
</ul>
<h4 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h4><hr>
<ul>
<li><img src="/2019/05/26/复习/41.png" alt="41"></li>
<li><img src="/2019/05/26/复习/42.png" alt="42"></li>
<li><img src="/2019/05/26/复习/43.png" alt="43"></li>
</ul>
<h5 id="HashMap-、HashTable-、ConcurrentHashMap"><a href="#HashMap-、HashTable-、ConcurrentHashMap" class="headerlink" title="HashMap 、HashTable 、ConcurrentHashMap"></a>HashMap 、HashTable 、ConcurrentHashMap</h5><hr>
<ul>
<li>HashMap<ul>
<li>Java8 以前是数组 + 链表</li>
<li>Java8 以后是数组 + 链表 + 红黑树</li>
<li>当 HashMap 链表大小超过 TREEIFY_THRESHOLD = 8 时，HashMap 将链表转换成红黑树，如果删除操作后，红黑树的节点小于 UNTREEIFY_THRESHOLD = 6 时，红黑树转换成链表</li>
</ul>
</li>
</ul>
<h3 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h3><hr>
<h4 id="IOC-–-控制反转"><a href="#IOC-–-控制反转" class="headerlink" title="IOC – 控制反转"></a>IOC – 控制反转</h4><p>依赖注入主要方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	setter</span><br><span class="line"></span><br><span class="line">​	interface</span><br><span class="line"></span><br><span class="line">​	constructor</span><br><span class="line"></span><br><span class="line">​	annotation</span><br></pre></td></tr></table></figure>
<h4 id="AOP-面向切面变成"><a href="#AOP-面向切面变成" class="headerlink" title="AOP 面向切面变成"></a>AOP 面向切面变成</h4><pre><code>##### AOP的三中织入方式
</code></pre><ul>
<li>编译时织入 ： 需要特殊的编译器  aspectJ</li>
<li>类加载时织入： 需要特殊的编译器</li>
<li>运行时织入： spring 采用的方式 采用动态代理的方式</li>
</ul>
<p><img src="/2019/05/26/复习/AOP重要名词概念.png" alt="1552823437180"></p>
<p><img src="/2019/05/26/复习/Advice种类2.png" alt="1552823486682"></p>
<p>代理方法 ： </p>
<ul>
<li>CGlib  修改字节码生成子类来实现的</li>
<li>Proxy  动态代理</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/26/复习/" data-id="cjw54xaf80001b8v3g3umy6ac" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/26/hello-world/" class="article-date">
  <time datetime="2019-05-26T15:24:40.324Z" itemprop="datePublished">2019-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/26/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/26/hello-world/" data-id="cjw54xac00000b8v3fdxcfwc6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/26/复习/">Test</a>
          </li>
        
          <li>
            <a href="/2019/05/26/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>